# Implementation Plan: Speck - Claude Code-Optimized Specification Framework

**Branch**: `001-speck-core-project` | **Date**: 2025-11-14 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `specs/001-speck-core-project/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command after consulting upstream architecture documents and TypeScript design patterns.

## Summary

Speck is a living derivative of GitHub's spec-kit methodology, optimized for Claude Code with native slash commands, agents, and skills. The implementation follows a **Claude Agent-Powered Transformation** architecture (from SYNC_ARCHITECTURE.md) where upstream spec-kit commands are semantically transformed into Claude Code-enhanced versions with preserved extension markers. Primary technical approach: Bun-powered TypeScript CLI with GitHub Releases-based upstream sync, maintaining 100% file format compatibility with spec-kit's `specs/` directory structure.

## Technical Context

**Language/Version**: TypeScript 5.3+ with Bun 1.0+ runtime (primary), Deno 1.40+ compatibility (secondary)
**Primary Dependencies**:
- Bun runtime (native TypeScript execution, fast I/O, built-in test runner)
- Commander.js (CLI framework)
- Zod (type-safe validation schemas)
- Handlebars (template rendering)
- Marked (markdown parsing)
- Prompts (interactive CLI prompts)
- Chalk/Ora (CLI output formatting)

**Storage**: File system-based (markdown files in `specs/` directory), JSON tracking files in `.speck/`, no database required
**Testing**: Bun's built-in test runner for unit/integration tests, manual E2E validation via Claude Code slash commands
**Target Platform**: macOS, Linux, Windows (via Bun cross-platform support); Claude Code as primary IDE environment
**Project Type**: Dual-mode CLI tool (TypeScript CLI + Claude Code integration) with hybrid architecture

**Performance Goals**:
- CLI startup time: <100ms (Bun native TS execution)
- Spec generation: <2 minutes end-to-end (SC-001)
- Upstream sync: <5 minutes including AI transformation (SC-004)

**Constraints**:
- File format compatibility: 100% compatible with spec-kit's on-disk format (Constitution Principle VII)
- Extension preservation: 100% of Speck-specific enhancements survive upstream sync (Constitution Principle II)
- Branch name length: ≤244 characters (git limitation)
- Clarification markers: Max 3 per spec during generation, up to 5 questions during clarification workflow

**Scale/Scope**:
- Support 10+ parallel features via worktrees without cross-contamination (SC-006)
- Handle repos with 100+ features
- Sync with monthly upstream spec-kit releases (SC-008: 80% conflict-free)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Upstream Fidelity ✅ PASS
**Requirement**: Maintain compatibility with spec-kit methodology; preserve sync capability with upstream releases.

**Status**: COMPLIANT
- GitHub Releases-based sync strategy tracks upstream spec-kit versions
- Extension markers (`[SPECK-EXTENSION:START/END]`) protect enhancements
- `/speck.transform-upstream` command enables semantic synchronization
- File format compatibility maintained via Constitution Principle VII

**Evidence**: Architecture follows SYNC_ARCHITECTURE.md's Claude Agent-Powered Transformation approach, ensuring continuous upstream alignment.

---

### Principle II: Extension Preservation ✅ PASS
**Requirement**: All Speck-specific enhancements MUST be preserved during upstream sync (NON-NEGOTIABLE).

**Status**: COMPLIANT
- Extension marker system implemented in tracking infrastructure
- Claude agent instructions explicitly preserve marked code blocks
- Sync manifest tracks extensions per file
- Transformation reports document preservation actions

**Evidence**: Extension-markers.json tracks all Speck-only code; sync agent trained to never modify content within boundaries.

---

### Principle III: Specification-First Development ✅ PASS
**Requirement**: Features begin with technology-agnostic specs; no implementation details in specs.

**Status**: COMPLIANT
- This implementation plan follows the mandatory workflow: Specify → Clarify → Plan → Tasks → Implement
- Spec (spec.md) contains zero implementation details (references methodology, not tech stack)
- Quality validation enforces "no frameworks/languages in specs" (SC-002)
- Template validation flags technical jargon

**Evidence**: Feature spec focuses on user scenarios and requirements without mentioning TypeScript, Bun, or specific libraries.

---

### Principle IV: Quality Gates ✅ PASS
**Requirement**: Automated validation before phase progression; 95% first-pass success target.

**Status**: COMPLIANT
- Zod schemas validate all artifacts (specs, plans, tasks)
- Checklist generation enforced via SpecificationService
- Constitutional validation via spec-analyzer skill
- Quality metrics tracked (SC-003: 95% pass rate)

**Evidence**: TypeScript design includes dedicated validator services (SpecValidator, ConstitutionValidator, CrossArtifactValidator).

---

### Principle V: Claude Code Native ✅ PASS
**Requirement**: Workflows optimized for Claude Code; slash commands, agents, skills as first-class citizens.

**Status**: COMPLIANT
- All workflows implemented as slash commands (`.claude/commands/speck.*.md`)
- Long-running processes delegate to agents (clarification-agent, research-agent)
- Reusable patterns extracted to skills (template-renderer, spec-analyzer)
- TypeScript CLI provides parity for non-Claude Code users (<1% deviation per SC-005)

**Evidence**: Dual-mode architecture with Claude Code as primary, CLI as secondary interface.

---

### Principle VI: Technology Agnosticism ✅ PASS
**Requirement**: Core methodology and templates remain technology-agnostic.

**Status**: COMPLIANT
- Templates are markdown files with placeholders (no code)
- Runtime implementations (Bun CLI) don't leak into spec artifacts
- Success criteria focus on user outcomes (SC-001 through SC-010)
- Template validation actively rejects technical jargon

**Evidence**: `specs/` directory contains only methodology artifacts; `.speck/` and `src/` contain implementations.

---

### Principle VII: File Format Compatibility ✅ PASS
**Requirement**: 100% compatibility with spec-kit's on-disk format; drop-in replacement without migration (NON-NEGOTIABLE).

**Status**: COMPLIANT
- `specs/<number>-<short-name>/` directory structure matches spec-kit
- File names match: `spec.md`, `plan.md`, `tasks.md`, `checklists/*.md`
- Branch naming convention: `<number>-<short-name>` (3-digit zero-padded)
- Speck metadata stored outside `specs/` in `.speck/` directory
- Feature numbering scheme identical

**Evidence**: Architecture explicitly prioritizes file format parity; projects can switch between Speck and spec-kit freely.

---

### Upstream Sync Requirements ✅ PASS
**Requirement**: Release-based sync; semantic transformation via Claude agent.

**Status**: COMPLIANT
- Release tracking in `upstream/.release-info.json`
- Symlink pattern: `upstream/spec-kit/current → v0.0.85/`
- Commands: `/speck.check-upstream-releases`, `/speck.download-upstream`, `/speck.transform-upstream`
- Semantic transformation via Claude agent (not mechanical regex replacement)

**Evidence**: SYNC_ARCHITECTURE.md documents complete release-based workflow with Claude agent instructions.

---

### Development Workflow ✅ PASS
**Requirement**: Feature isolation via worktrees; mandatory workflow phases.

**Status**: COMPLIANT
- Git worktree support via FeatureService and WorktreeAdapter
- Feature numbering checks branches, worktrees, AND specs directories
- Isolated/shared specs modes supported (auto-detect based on git tracking)
- Workflow enforcement: Specify → Clarify → Plan → Tasks → Implement → Analyze

**Evidence**: TypeScript design includes WorktreeAdapter and FeatureService with createWorktreeFeature method.

---

### Testability ✅ PASS
**Requirement**: Requirements independently testable; user stories independently implementable as MVPs.

**Status**: COMPLIANT
- All 5 user stories in spec.md include "Independent Test" descriptions
- Acceptance scenarios use Given-When-Then format
- Edge cases explicitly documented
- Success criteria verifiable without implementation knowledge (SC-001 through SC-010)

**Evidence**: Each user story can be shipped independently as a viable increment.

---

## Constitution Check Summary

**Overall Status**: ✅ ALL GATES PASSED

| Principle | Status | Critical Issues |
|-----------|--------|----------------|
| I. Upstream Fidelity | ✅ PASS | None |
| II. Extension Preservation | ✅ PASS | None (NON-NEGOTIABLE satisfied) |
| III. Specification-First | ✅ PASS | None |
| IV. Quality Gates | ✅ PASS | None |
| V. Claude Code Native | ✅ PASS | None |
| VI. Technology Agnosticism | ✅ PASS | None |
| VII. File Format Compatibility | ✅ PASS | None (NON-NEGOTIABLE satisfied) |
| Upstream Sync | ✅ PASS | None |
| Development Workflow | ✅ PASS | None |
| Testability | ✅ PASS | None |

**Proceed to Phase 0: Research & Outline** ✅

## Project Structure

### Documentation (this feature)

```text
specs/001-speck-core-project/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0 output - architecture decisions & rationale
├── data-model.md        # Phase 1 output - domain models and entities
├── quickstart.md        # Phase 1 output - getting started guide
├── contracts/           # Phase 1 output - API contracts (CLI commands)
│   ├── specify.schema.json
│   ├── clarify.schema.json
│   ├── plan.schema.json
│   ├── tasks.schema.json
│   └── transform-upstream.schema.json
└── tasks.md             # Phase 2 output (via /speckit.tasks - NOT created here)
```

### Source Code (repository root)

Based on the TypeScript design document and Speck's dual-mode architecture (Claude Code + CLI), the project structure is:

```text
speck/                                    # Project root
│
├── .claude/                              # Claude Code integration (generated from upstream)
│   ├── .generated                        # Marker: these are generated artifacts
│   ├── commands/                         # Slash commands (enhanced from spec-kit)
│   │   ├── _metadata.json               # Compilation metadata
│   │   ├── speck.specify.md
│   │   ├── speck.clarify.md
│   │   ├── speck.plan.md
│   │   ├── speck.tasks.md
│   │   ├── speck.implement.md
│   │   ├── speck.analyze.md
│   │   ├── speck.constitution.md
│   │   ├── speck.checklist.md
│   │   └── speck.transform-upstream.md  # Upstream sync command
│   ├── agents/                           # Extracted autonomous agents
│   │   ├── _metadata.json
│   │   ├── clarification-agent.md
│   │   ├── research-agent.md
│   │   └── specification-agent.md
│   └── skills/                           # Reusable skills (extracted patterns)
│       ├── _metadata.json
│       ├── template-renderer.md
│       ├── spec-analyzer.md
│       └── constitution-validator.md
│
├── .speck/                               # Speck-specific metadata (never in specs/)
│   ├── upstream-tracker.json            # Last synced commit SHA, sync status
│   ├── sync-manifest.json               # Maps upstream → Speck artifacts
│   ├── extension-markers.json           # Tracks Speck-only code blocks
│   └── sync-reports/                    # Historical sync reports
│       └── YYYY-MM-DD-sync.md
│
├── upstream/                             # Pristine upstream spec-kit releases
│   └── spec-kit/
│       ├── .release-info.json           # Release metadata
│       ├── current -> v0.0.85/          # Symlink to active version
│       ├── v0.0.85/                     # Latest release
│       │   └── templates/
│       │       ├── commands/
│       │       ├── spec-template.md
│       │       ├── plan-template.md
│       │       └── tasks-template.md
│       └── v0.0.84/                     # Previous release (for diffing)
│
├── src/                                  # TypeScript CLI implementation
│   ├── cli/                             # CLI entry points
│   │   ├── index.ts                     # Main CLI entry
│   │   ├── commands/                    # Command implementations
│   │   │   ├── specify.ts
│   │   │   ├── clarify.ts
│   │   │   ├── plan.ts
│   │   │   ├── tasks.ts
│   │   │   ├── checklist.ts
│   │   │   ├── analyze.ts
│   │   │   ├── implement.ts
│   │   │   └── constitution.ts
│   │   └── shared/                      # Shared CLI utilities
│   │       ├── prompts.ts
│   │       ├── output.ts
│   │       └── validation.ts
│   │
│   ├── core/                            # Domain logic (runtime-agnostic)
│   │   ├── models/                      # Domain models
│   │   │   ├── Feature.ts
│   │   │   ├── Specification.ts
│   │   │   ├── Plan.ts
│   │   │   ├── Task.ts
│   │   │   ├── Checklist.ts
│   │   │   └── Constitution.ts
│   │   ├── services/                    # Business logic services
│   │   │   ├── FeatureService.ts
│   │   │   ├── SpecificationService.ts
│   │   │   ├── PlanningService.ts
│   │   │   ├── TaskGenerationService.ts
│   │   │   ├── ChecklistService.ts
│   │   │   ├── AnalysisService.ts
│   │   │   └── ImplementationService.ts
│   │   ├── generators/                  # Content generation
│   │   │   ├── SpecGenerator.ts
│   │   │   ├── PlanGenerator.ts
│   │   │   ├── TaskGenerator.ts
│   │   │   └── ChecklistGenerator.ts
│   │   └── validators/                  # Validation logic
│   │       ├── SpecValidator.ts
│   │       ├── ConstitutionValidator.ts
│   │       └── CrossArtifactValidator.ts
│   │
│   ├── adapters/                        # External service adapters
│   │   ├── git/
│   │   │   ├── GitAdapter.ts           # Git abstraction
│   │   │   ├── BunGitAdapter.ts        # Bun implementation
│   │   │   └── WorktreeAdapter.ts      # Worktree operations
│   │   ├── filesystem/
│   │   │   ├── FileSystemAdapter.ts    # FS abstraction
│   │   │   └── BunFsAdapter.ts         # Bun implementation
│   │   ├── runtime/
│   │   │   ├── RuntimeAdapter.ts       # Runtime abstraction layer
│   │   │   └── BunRuntimeAdapter.ts    # Bun-specific implementation
│   │   └── template/
│   │       ├── TemplateEngine.ts       # Template abstraction
│   │       └── HandlebarsAdapter.ts    # Handlebars implementation
│   │
│   ├── config/                          # Configuration management
│   │   ├── ConfigLoader.ts
│   │   ├── schemas/
│   │   │   ├── SpeckConfig.ts          # Zod schema for config
│   │   │   └── WorktreeConfig.ts
│   │   └── defaults.ts
│   │
│   ├── utils/                           # Shared utilities
│   │   ├── paths.ts
│   │   ├── validation.ts
│   │   ├── markdown.ts
│   │   ├── json.ts
│   │   └── logger.ts
│   │
│   └── types/                           # Shared type definitions
│       ├── index.ts
│       ├── git.ts
│       ├── artifacts.ts
│       └── config.ts
│
├── .specify/                             # Legacy spec-kit compatibility layer
│   ├── memory/
│   │   └── constitution.md              # Project constitution
│   ├── templates/                       # Markdown templates
│   │   ├── spec-template.md
│   │   ├── plan-template.md
│   │   ├── tasks-template.md
│   │   └── checklist-template.md
│   └── scripts/                         # Setup scripts
│       └── bash/
│           ├── setup-plan.sh
│           └── check-prerequisites.sh
│
├── specs/                                # Feature specifications (spec-kit compatible)
│   └── 001-speck-core-project/          # This feature
│
├── tests/                                # Test suites
│   ├── unit/                            # Unit tests (Bun test runner)
│   │   ├── FeatureService.test.ts
│   │   ├── GitAdapter.test.ts
│   │   └── SpecValidator.test.ts
│   ├── integration/                     # Integration tests
│   │   ├── specify-command.test.ts
│   │   └── worktree-creation.test.ts
│   └── e2e/                             # End-to-end tests
│       └── full-workflow.test.ts
│
├── package.json                         # npm/Bun package config
├── bunfig.toml                          # Bun configuration
├── tsconfig.json                        # TypeScript config
├── speck.config.ts                      # User-facing Speck configuration
└── README.md
```

**Structure Decision**:

This is a **hybrid TypeScript CLI + Claude Code integration project** combining:

1. **Claude Code Layer** (`.claude/`): Generated slash commands, agents, and skills from upstream spec-kit templates with Speck enhancements
2. **TypeScript Core** (`src/`): Hexagonal architecture with clean separation:
   - `cli/`: Command-line interface using Commander.js
   - `core/`: Domain logic (framework-agnostic)
   - `adapters/`: External service abstractions (Git, FS, Runtime)
   - `config/`: Type-safe configuration with Zod schemas
3. **Upstream Tracking** (`upstream/`, `.speck/`): GitHub Releases-based sync infrastructure
4. **Spec-Kit Compatibility** (`.specify/`, `specs/`): Maintains 100% file format compatibility

The structure supports the dual-mode architecture where users can interact via:
- **Claude Code** (primary): `/speck.specify`, `/speck.clarify`, etc.
- **CLI** (secondary): `speck specify`, `speck clarify`, etc.

Both interfaces share the same core domain logic (`src/core/`) ensuring behavioral parity (<1% deviation per SC-005).

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**Status**: No constitutional violations detected. All gates passed. This section intentionally left empty.

All architectural decisions (hexagonal architecture, dual-mode CLI, Claude agent-powered sync) are aligned with constitutional principles and justified by:
- **Principle I (Upstream Fidelity)**: GitHub Releases-based sync + semantic transformation
- **Principle V (Claude Code Native)**: Dual-mode architecture prioritizes Claude Code integration
- **Principle VII (File Format Compatibility)**: Clean separation between implementation (`src/`, `.claude/`) and spec artifacts (`specs/`)

No additional complexity justification required.

---

## Post-Phase 1 Constitution Re-Evaluation

*Required: Re-check after Phase 1 design (research.md, data-model.md, contracts/, quickstart.md generated)*

### Summary

All constitutional principles remain compliant after Phase 1 design completion. No new violations introduced.

### Detailed Re-Check

| Principle | Status | Post-Design Evidence |
|-----------|--------|---------------------|
| **I. Upstream Fidelity** | ✅ PASS | research.md documents Claude Agent-Powered Transformation strategy with GitHub Releases-based sync; contracts/ define behavioral parity between CLI and slash commands |
| **II. Extension Preservation** | ✅ PASS | data-model.md includes UpstreamTracker and SyncedFile entities to track extension markers; sync-manifest.json structure defined |
| **III. Specification-First** | ✅ PASS | data-model.md defines Specification entity with zero-implementation-detail validation; SpecValidator enforces SC-002 |
| **IV. Quality Gates** | ✅ PASS | data-model.md defines Checklist entity, ValidationError/ValidationWarning types; Zod schemas enforce 95% first-pass success target |
| **V. Claude Code Native** | ✅ PASS | contracts/ define slash command schemas; quickstart.md demonstrates Claude Code as primary interface with CLI as secondary |
| **VI. Technology Agnosticism** | ✅ PASS | data-model.md Specification entity explicitly validates technology-agnostic success criteria; research.md confirms templates remain markdown-based |
| **VII. File Format Compatibility** | ✅ PASS | Project structure maintains `specs/<number>-<short-name>/` layout; Feature entity enforces 3-digit numbering and branch naming conventions |
| **Upstream Sync** | ✅ PASS | research.md documents complete GitHub Releases workflow; contracts/transform-upstream.schema.json defines semantic transformation contract |
| **Development Workflow** | ✅ PASS | data-model.md defines Feature entity with worktree support; quickstart.md documents auto-detect specs mode (git-tracked vs gitignored) |
| **Testability** | ✅ PASS | research.md documents Bun test runner strategy with unit/integration/E2E layers; contracts/ provide testable API specifications |

### New Risks Identified: None

All Phase 1 artifacts (research.md, data-model.md, contracts/, quickstart.md) reinforce constitutional compliance. No architectural decisions introduce new risks or violations.

### Recommendation

**✅ APPROVED**: Proceed to Phase 2 (Tasks generation via `/speckit.tasks` command)

---

## Phase Summary

### Phase 0: Research & Outline ✅ COMPLETED

**Artifacts Generated**:
- [research.md](research.md) - All NEEDS CLARIFICATION items resolved, architecture decisions documented

**Key Decisions**:
1. Claude Agent-Powered Transformation (not compiler-based)
2. Bun-only runtime (not dual Bun/Deno)
3. Auto-detect worktree specs mode (git-tracked vs gitignored)
4. Commander.js CLI framework
5. Handlebars template engine
6. Zod validation schemas
7. Hexagonal architecture (Ports & Adapters)

### Phase 1: Design & Contracts ✅ COMPLETED

**Artifacts Generated**:
- [data-model.md](data-model.md) - 8 core domain entities with Zod schemas
- [contracts/](contracts/) - JSON Schema contracts for CLI commands
  - [specify.schema.json](contracts/specify.schema.json)
  - [transform-upstream.schema.json](contracts/transform-upstream.schema.json)
  - [README.md](contracts/README.md)
- [quickstart.md](quickstart.md) - Complete getting started guide

**Agent Context Updated**:
- [CLAUDE.md](/Users/nathan/git/github.com/nprbst/speck/CLAUDE.md) - Technology stack added (TypeScript 5.3+, Bun 1.0+, file-based storage)

### Phase 2: Tasks (NOT Generated by `/speckit.plan`)

**Next Command**: `/speckit.tasks`

This will generate:
- `tasks.md` - Dependency-ordered implementation tasks with priorities and acceptance criteria

**Important**: Phase 2 is executed via a separate command (`/speckit.tasks`), not by `/speckit.plan`. The planning phase stops here as specified in the workflow outline.

---

## Final Notes

This implementation plan is complete and ready for task generation. All constitutional gates passed, all Phase 0 and Phase 1 artifacts generated, and agent context updated.

**Branch**: `001-speck-core-project`
**Status**: Ready for `/speckit.tasks`
**Next Step**: Run `/speckit.tasks` to generate actionable task breakdown
